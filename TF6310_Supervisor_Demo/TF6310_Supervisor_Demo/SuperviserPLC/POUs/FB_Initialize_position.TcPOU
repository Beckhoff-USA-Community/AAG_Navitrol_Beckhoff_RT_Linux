<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.17">
  <POU Name="FB_Initialize_position" Id="{c0810175-5c65-435a-abbe-5c7a266901a8}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Initialize_position
VAR_INPUT
	RemoteHost				   : T_IPv4Addr;
	RemotePort				   : UDINT;
	st1001_Initialize_position : ST_1001_Initialize_position := (X := 100.0, Y := 150.0);
	Execute					   : BOOL;
END_VAR

VAR_OUTPUT
	Busy						: BOOL;
	Error						: BOOL;
	ErrorID						: UDINT;
	st1101_Position_initialized : ST_1101_Position_initialized;
END_VAR

VAR
	rtExecute : R_TRIG;
	State	  : (INIT_FBs,
		CONNECT_TO_Server,
		SEND_1001,
		RECEIVE_DATA,
		CLOSE_CONNECTION);
	Connect								   : FB_SocketConnect;
	Send								   : FB_SocketSend;
	Close								   : FB_SocketClose;
	Receive								   : FB_SocketReceive;
	ReceiveBuffer						   : U_Recived_bytes_from_Navitrol;
	st1100_Position_initialization_started : ST_1100_Position_initialization_started;
	
		UnknowMsgRecivedCounter : UDINT;
	UnknowMsg				: U_Recived_bytes_from_Navitrol;

	//Event logging
	FirstScan  : BOOL := TRUE;
	ErrorMsg   : FB_TcMessage;
	VerboseMsg : FB_TcMessage;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF FirstScan THEN
	ErrorMsg.CreateEx(stEventEntry := TC_EVENTS.TcpIpComms.ErrorMsg, ipSourceInfo := 0);
	VerboseMsg.CreateEx(stEventEntry := TC_EVENTS.TcpIpComms.VerboseMsg, ipSourceInfo := 0);
	FirstScan := FALSE;
END_IF

rtExecute(CLK := Execute);
CASE State OF
	INIT_FBs: // Init State
		Connect(bExecute := FALSE);
		Send(bExecute := FALSE);
		Receive(bExecute := FALSE);
		Close(bExecute := FALSE);
		Busy := FALSE;
		IF rtExecute.Q THEN
			State := CONNECT_TO_Server;
			Busy  := TRUE;
			Error := FALSE;
		END_IF

	CONNECT_TO_Server:
		Connect(sSrvNetId	:= '',
				sRemoteHost := RemoteHost,
				nRemotePort := RemotePort,
				bExecute	:= TRUE,
				tTimeout	:= T#4S);

		IF Connect.hSocket.handle <> 0 AND NOT (Connect.bBusy) THEN
			State := SEND_1001;
			VerboseMsg.ipArguments.Clear().AddString('Connected to server:').AddString(RemoteHost).AddUDInt(RemotePort).AddString('local port').AddUDInt(Connect.hSocket.localAddr.nPort);
			VerboseMsg.Send();
		ELSIF Connect.bError THEN
			State := INIT_FBs;
			Error := TRUE;
			ErrorMsg.ipArguments.Clear().AddString('Failed to connect to server:').AddString(RemoteHost).AddUDInt(RemotePort).AddString(', Error:').AddUDInt(Connect.nErrId);
			ErrorMsg.Send();
		END_IF

	SEND_1001:
		Send(sSrvNetId := '',
			 hSocket   := Connect.hSocket,
			 cbLen	   := SIZEOF(st1001_Initialize_position),
			 pSrc	   := ADR(st1001_Initialize_position),
			 bExecute  := TRUE,
			 tTimeout  := T#2S);

		IF NOT Send.bBusy THEN
			IF NOT Send.bError THEN
				State := RECEIVE_DATA;
			ELSE
				Error	:= TRUE;
				ErrorID := Send.nErrID;
				State	:= CLOSE_CONNECTION;
			END_IF

			Send(bExecute := FALSE);
		END_IF

	RECEIVE_DATA:
		Receive( // ReceiveData
			sSrvNetId := '',
			hSocket	  := Connect.hSocket,
			cbLen	  := SIZEOF(ReceiveBuffer),
			pDest	  := ADR(ReceiveBuffer),
			bExecute  := TRUE,
			tTimeout  := T#3S);

		IF NOT Receive.bBusy AND Receive.nRecBytes <> 0 THEN // Check cyclically for new data
			IF NOT Receive.bError THEN
				CASE ReceiveBuffer.Header.Message_ID OF
					1100:
						MEMCPY(destAddr := ADR(st1100_Position_initialization_started), srcAddr := ADR(ReceiveBuffer), n := SIZEOF(st1100_Position_initialization_started));
						VerboseMsg.ipArguments.Clear().AddString('Position intilization started');
						VerboseMsg.Send();

					1101:
						MEMCPY(destAddr := ADR(st1101_Position_initialized), srcAddr := ADR(ReceiveBuffer), n := SIZEOF(st1101_Position_initialized));
						VerboseMsg.ipArguments.Clear().AddString('Position intialized');
						VerboseMsg.Send();
						State := CLOSE_CONNECTION;

				ELSE
					UnknowMsgRecivedCounter := UnknowMsgRecivedCounter + 1;
					MEMCPY(destAddr := ADR(UnknowMsg), srcAddr := ADR(ReceiveBuffer), n := SIZEOF(UnknowMsg));
					ErrorMsg.ipArguments.Clear().AddString('Unknow msg type recived with ID:').AddUInt(ReceiveBuffer.Header.Message_ID);
					ErrorMsg.Send();
				END_CASE
			ELSE
				Error	:= TRUE;
				ErrorID := ErrorID;
				State	:= CLOSE_CONNECTION;
			END_IF

			Receive(bExecute := FALSE);
		END_IF

	CLOSE_CONNECTION:
		Close( // Close connection
			sSrvNetId := '',
			hSocket	  := Connect.hSocket,
			tTimeout  := T#4S);

		IF NOT Close.bBusy THEN
			Close(bExecute := FALSE);
			State := INIT_FBs;
		END_IF
END_CASE]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>