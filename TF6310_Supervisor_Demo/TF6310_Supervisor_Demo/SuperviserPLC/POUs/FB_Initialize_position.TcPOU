<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.17">
  <POU Name="FB_Initialize_position" Id="{c0810175-5c65-435a-abbe-5c7a266901a8}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Initialize_position
VAR_INPUT
	RemoteHost : T_IPv4Addr;
	RemotePort : UDINT;
	X		   : REAL; //		X - map coordinate OF the AGV in meters
	Y		   : REAL; //		Y - map coordinate of the AGV in meters
	H		   : REAL; //		Heading of the AGV on the map in radians
	Level	   : DINT; //	The level ID on which the AGV is located	
	Execute	   : BOOL;
END_VAR

VAR_OUTPUT
	Busy				  : BOOL;
	Error				  : BOOL;
	ErrorID				  : UDINT;
	X_act				  : REAL;  //	X-map coordinate OF the new position in meters
	Y_act				  : REAL;  //	Y-map coordinate of the new position in meters
	H_act				  : REAL;  //	Heading of the new position on the map in radians
	Floor_act			  : UDINT; //		The floor of the new position
	Initialization_result : UINT;  (*	0 - Failure
		The position initialization can fail for example if
			- A good position is not found within pos_ini_max_d..-parameters from the given pos init point
			- A good position is not found within value of pos_init_max_wait_time-parameter
			- The AGV is not stationary state, it is performing load or there are scanner related errors active.
		1 - Success
			- A good position was found near the given position initialization point and position was successfully initialized.*)
	Position_confidence : UINT; //		Position confidence percentage (1 - 100%)Describes how well the laser measurements in the new position matches the seen environment.	
END_VAR

VAR
	rtExecute : R_TRIG;
	State	  : (INIT_FBs,
		CONNECT,
		SEND_1001,
		RECEIVE_1100,
		RECIVE_1101,
		CLOSE_CONNECTION);
	SocketConnect						   : FB_SocketConnect;
	SocketSend							   : FB_SocketSend;
	SocketClose							   : FB_SocketClose;
	SocketReceive						   : FB_SocketReceive;
	Timer								   : TON;
	st1001_Initialize_position			   : ST_1001_Initialize_position := (X := 100.0, Y := 150.0);
	st1100_Position_initialization_started : ST_1100_Position_initialization_started;
	st1101_Position_initialized			   : ST_1101_Position_initialized;

	//Event logging
	FirstScan  : BOOL := TRUE;
	ErrorMsg   : FB_TcMessage;
	VerboseMsg : FB_TcMessage;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF FirstScan THEN
	ErrorMsg.CreateEx(stEventEntry := TC_EVENTS.TcpIpComms.ErrorMsg, ipSourceInfo := 0);
	VerboseMsg.CreateEx(stEventEntry := TC_EVENTS.TcpIpComms.VerboseMsg, ipSourceInfo := 0);
	FirstScan := FALSE;
END_IF

rtExecute(CLK := Execute);
CASE State OF
	INIT_FBs: // Init State
		SocketConnect(bExecute := FALSE);
		SocketSend(bExecute := FALSE);
		SocketReceive(bExecute := FALSE);
		SocketClose(bExecute := FALSE);
		Busy := FALSE;
		IF rtExecute.Q THEN
			st1001_Initialize_position.X	 := X;
			st1001_Initialize_position.Y	 := Y;
			st1001_Initialize_position.H	 := H;
			st1001_Initialize_position.Level := Level;
			State							 := CONNECT;
			Busy							 := TRUE;
			Error							 := FALSE;
			VerboseMsg.ipArguments.Clear().AddString('Starting communications to:').AddString(RemoteHost).AddUDInt(RemotePort);
			VerboseMsg.Send();
		END_IF

	CONNECT:
		SocketConnect(sSrvNetId	  := '',
					  sRemoteHost := RemoteHost,
					  nRemotePort := RemotePort,
					  bExecute	  := TRUE,
					  tTimeout	  := T#4S);

		IF SocketConnect.hSocket.handle <> 0 AND NOT (SocketConnect.bBusy) THEN
			State := SEND_1001;
			VerboseMsg.ipArguments.Clear().AddString('Connected to server:').AddString(RemoteHost).AddUDInt(RemotePort);
			VerboseMsg.Send();
		ELSIF Error THEN
			State := INIT_FBs;
			ErrorMsg.ipArguments.Clear().AddString('Failed to connect to server:').AddString(RemoteHost).AddUDInt(RemotePort).AddString(', Error:').AddUDInt(SocketConnect.nErrId);
			ErrorMsg.Send();
		END_IF

	SEND_1001:
		SocketSend(sSrvNetId := '',
				   hSocket	 := SocketConnect.hSocket,
				   cbLen	 := SIZEOF(st1001_Initialize_position),
				   pSrc		 := ADR(st1001_Initialize_position),
				   bExecute	 := TRUE,
				   tTimeout	 := T#2S);

		IF NOT SocketSend.bBusy THEN
			IF NOT SocketSend.bError THEN
				State := RECEIVE_1100;
			ELSE
				Error	:= TRUE;
				ErrorID := SocketSend.nErrID;
				State	:= CLOSE_CONNECTION;
			END_IF

			SocketSend(bExecute := FALSE);
		END_IF

	RECEIVE_1100:
		SocketReceive( // ReceiveData
			sSrvNetId := '',
			hSocket	  := SocketConnect.hSocket,
			cbLen	  := SIZEOF(st1100_Position_initialization_started),
			pDest	  := ADR(st1100_Position_initialization_started),
			bExecute  := TRUE,
			tTimeout  := T#3S);

		IF NOT SocketReceive.bBusy THEN // Check cyclically for new data
			IF NOT SocketReceive.bError THEN
				IF st1100_Position_initialization_started.nMessageID = 1100 THEN
					State := RECIVE_1101;
				END_IF
			ELSE
				Error	:= TRUE;
				ErrorID := ErrorID;
				State	:= CLOSE_CONNECTION;
			END_IF

			SocketReceive(bExecute := FALSE);
		END_IF

	RECIVE_1101:
		SocketReceive( // ReceiveData
			sSrvNetId := '',
			hSocket	  := SocketConnect.hSocket,
			cbLen	  := SIZEOF(st1101_Position_initialized),
			pDest	  := ADR(st1101_Position_initialized),
			bExecute  := TRUE,
			tTimeout  := T#3S);

		IF NOT SocketReceive.bBusy THEN // Check cyclically for new data
			IF NOT SocketReceive.bError THEN
				IF st1101_Position_initialized.nMessageID = 1101 THEN
					State := CLOSE_CONNECTION;
					X_act:=st1101_Position_initialized.X;
					Y_act:=st1101_Position_initialized.Y;
					H_act:=st1101_Position_initialized.H;
					Floor_act:=st1101_Position_initialized.Floor;
					Initialization_result:=st1101_Position_initialized.Initialization_result;
					Position_confidence:=st1101_Position_initialized.Position_confidence;
				END_IF
			ELSE
				Error	:= TRUE;
				ErrorID := ErrorID;
				State	:= CLOSE_CONNECTION;
			END_IF

			SocketReceive(bExecute := FALSE);
		END_IF

	CLOSE_CONNECTION:
		SocketClose( // Close connection
			sSrvNetId := '',
			hSocket	  := SocketConnect.hSocket,
			bExecute  := TRUE,
			tTimeout  := T#4S);

		IF NOT SocketClose.bBusy THEN
			SocketClose(bExecute := FALSE);
			State := INIT_FBs;
		END_IF
END_CASE]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>